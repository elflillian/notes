# 指针

##### 如何定义指针变量

指针变量指的是定义存放变量地址的变量，定义指针变量如下：

```c
int    *p1;        //p1是指向int型变量的指针变量
float  *p2;        //p2是指向float型变量的指针变量
double  *p3;       //p3是指向double型变量的指针变量
char  *p4;         //p4是指向char型变量的指针变量
```

`*`是一个特殊符号，表明一个变量是指针变量，定义指针变量时必须带`*`，而给指针变量赋值时，就没必要再带上`*`，后边可以像使用普通变量一样来使用指针变量。也就是说，定义指针变量时必须带`*`，给指针变量赋值时不能带`*`。

<video src="https://video.educoder.net/sv/222c00da-173a998a8e9/222c00da-173a998a8e9.mp4" controls="true" controlslist="nodownload" width="90%" height="55%" poster="https://video.educoder.net/644eef05dcba48379981c4f22758bfdb/snapshots/da71d5347a344855b7dc5a4daceac99d-00005.jpg" style="box-sizing: border-box;"></video>

视频1 指针基本概念

##### 掌握两个与指针变量有关的运算符

**取地址运算符“&”** 指针变量同普通变量一样，使用之前不仅要定义说明，而且必须赋予具体的值。在 Ｃ 语言中，变量的地址是由编译系统分配的，对用户完全透明，用户不知道变量的具体地址。Ｃ 语言中提供了地址运算符`&`来表示变量的地址。

其一般形式为：`& 变量名`， 如`&a`变示变量`a`的地址，`&b`表示变量`b`的地址。

**取内容运算符“\*”** 取内容运算符“*”，用来表示指针变量所指向的变量内容（值），在“*”运算符之后跟的变量必须是指针变量。

示例如下：

```c
int *p,a;
p = &a;            //给指针变量p赋值时不能带*，&a表示变量a的内存地址
scanf("%d",p);     // 通过指针变量p从键盘输入数据赋给变量a，p和&a是等价的
printf("%d\n",*p);  // 通过指针变量p输出变量a的值，*p和a是等价的
```

##### 如何利用指针变量访问不同的变量

利用指针变量，通过改变它的指向，可以实现以相同的形式输入输出不同的变量值。

##### 基本数据类型和指针数据类型的区别

指针是一种特殊的，同时又是具有重要作用的数据类型。其值用来表示某个变量在内存储器中的地址。虽然指针变量的取值类似于整型量，但这是两个类型完全不同的量，因此不能混为一谈。

```c
int a = 100;       // 100为int型常量，a为int型变量
double b = 3.14;   // 3.14为double型常量，b为double型变量
int *pa = &a;      // &a为指针类型常量，&a值由系统分配得到，pa为指针变量
```

要注意的是，指针变量虽然存的是地址，但是不能用整型直接赋值的，比如：

```c
int *ptr;
ptr = 10;       //错误，不能直接用整型赋值
ptr = (int*)10; //可以通过强制类型转换赋值，但除非很了解内存布局，否则这么做一般会出现程序异常
```

但是有一个特例，那就是赋值 0 的时候，这个时候表达的含义是空指针，比如：

```c
int *ptr;
ptr = 0;          //这个是可以的
```

> **注意**：与其他变量一样，没有初始化或者赋值的指针变量存的值是随机的，如果此时直接使用`*`运算符，则会因为访问了不属于程序的内存位置而发生异常。也就是所谓的访问越界。

##### 指针变量的交换运算

指针变量保存的是地址，而地址本质上是一个整数，所以指针变量可以进行部分运算，例如加法、减法、比较等，还可以交换两个指针变量的值，指针变量可以像基本类型变量一样进行交换。

示例如下：

```c
int a = 100,b = 200;
int *pa = &a, *pb = &b,*temp;
temp = pa; pa = pb; pb = temp;
```



###### 1.指向数组元素的指针的运算 

###### 2.如何遍历数组。

<video src="https://video.educoder.net/sv/26548409-173a9abc49d/26548409-173a9abc49d.mp4" controls="true" controlslist="nodownload" width="90%" height="55%" poster="https://video.educoder.net/611b60f934f64170996d1f7a8fcdb81b/snapshots/39385c24441442ed9a0f8a861008a340-00005.jpg" style="box-sizing: border-box;"></video>

视频1 指针与一维数组

##### 指向数组元素的指针的运算

###### 指针与整数的加减运算

有数组和指针变量的定义如下：

```
int a[10],*p=a;
```

数组名代表数组的首地址，也就是数组元素`a[0]`的地址，现在指针变量`p`已指向数组中的第一个元素`a[0]`，假设`a[0]`的地址为`0x0022ff40`，则`p`的值为`0x0022ff40`，则`p+1`的值为`0x0022ff44`，`p+1`指向同一数组中的下一个元素，而`p-1`的值为`0x0022ff3c`，`p-1`指向同一数组中的上一个元素，数组已经越界，系统不做数组越界检查。同理， `p+i`指向数组的第`i`个数组元素`a[i]`。**指针与整数的加减运算结果是一个指针**。

###### 两个指针相减运算

有数组和指针变量的定义如下：

```
int a[10],*p1=&a[3],*p2=&a[5];
```

两个指针变量`p1`和`p2`可以进行相减运算，结果是一个整数，但是只有在`p1`和`p2`都指向同一数组中的元素时才有意义，现在`p1`指向`a[3]`，`p2`指向`a[5]`，那么`p2-p1`的值是整数 2，表示两个指针`p1`、`p2`之间数组元素的个数。

> **注意**：指针变量不能做加法运算，如不能有`p1+p2`的运算。

###### 两个指针的关系运算

有数组和指针变量的定义如下：

```
int a[10],*p1=&a[3],*p2=&a[5];
```

两个指针变量`p1`和`p2`可以进行比较运算，若`p1<p2`为真，则表示`p1`指向的数组元素在前，`p2`指向的数组元素在后；若`p1<p2`为假，则相反；若`p1==p2`，则表示`p1`与`p2`指向同一元素。若`p1`与`p2`不指向同一数组，比较无意义。指针变量还可以与`NULL`比较，表示是否指向了一个变量，如`p==NULL`或`p!=NULL`。

#### 数组逆置的算法思想

第一个数组元素和倒数第一个数组元素交换，第二个和倒数第二个交换，依次进行下去，直到交换的两个数组元素相遇。

**提示**：

```c
int a[10],*i,*j,temp;
i = &a[0];                  // 指针变量i指向数组元素a[0]
j = &a[9];                  // 指针变量i指向数组元素a[9]
temp = *i; *i = *j; *j=temp; // 交换数组元素a[0]和a[9]
i++;                         // 指针变量i指向数组元素a[1]
j--;                         // 指针变量j指向数组元素a[8]
```



###### 两种算法思想：一种是使用辅助数组实现数据移动；另一种是不使用辅助数组，只需一个中间变量就可实现数据移动。

##### 使用辅助数组实现数据移动

创建一个同样大小辅助数组，存放临时数据，最后将数据存回原数组。

```c
#include <stdio.h>
#define N 20
int main()
{    
    int a[N],b[N];   
    int i,n,m;    
    int *p;    
    printf("输入整数个数：");   
    scanf("%d",&n);     
    printf("输入%d个整数：\n",n);   
    for(i=0;i<n;i++)    
    {        
        scanf("%d",&a[i]);    
    } 
    p = a; 
    printf("输入移动位数：");  
    scanf("%d",&m);  
    for( i=0;i<n;i++)  
    {        
        b[i] = *(p+(i+m)%n);  
    }   
    for(i=0;i<n;i++) 
    {     
        a[i] = b[i];  
        printf("%d ",a[i]);   
    } 
    printf("\n");   
    return 0;
}
```

##### 不使用辅助数组实现数据移动

假如一个长度为`n=10`的数组中，原来的元素顺序为`（0 1 2 3 4 5 6 7 8 9）`，循环左移`m=3`个位置。不使用辅助数组实现数据移动的步骤如下：

- 第一步：首先逆置数组前`m`个元素，则数组中元素为`（2 1 0 3 4 5 6 7 8 9）`；
- 第二步：逆置余下`n-m`个元素，则数组中元素为`（2 1 0 9 8 7 6 5 4 3）`；
- 第三步：逆置整个数组`a`， 则数组中元素为`（3 4 5 6 7 8 9 0 1 2）`。

采用此算法仅需要很少的额外空间，**在时间和空间上都很高效**。

#### 不同数据类型所占内存的字节数

不同基本类型的数据占用的字节数不一样，例如 `int `占用 4 个字节，`char` 占用 1 个字节。数组是在其他数据类型的基础上构造出来的，是一种派生数据类型。

如果有一维数组定义如下：

```c
int  c[5], f[10];
```

那么编译器就在内存中为数组`c`分配了 5 个`int`类型的内存空间，共 5×4=20 个字节，并为它们起了一个名字，叫 c，数组`c`的类型是`int [5]`；同理数组`f`是类型是`int [10]`，占内存 40 个字节。数组类型所占字节数由数组元素的类型和数组长度决定。

如果有二维数组定义：

```c
int  s[3][4],t[2][5];
```

C 语言是把二维数组分解为多个一维数组来处理。数组`s`类型是`int [3][4]`，编译器将二维数组`s`分解为 3 个长度为 4 的一维数组`s[0]`、`s[1]`、`s[2]`，即这三个一维数组的类型是`int [4]`，在内存中是按行排列的，也就是先存放`s[0]`行，再存放`s[1]`行，最后存放`s[2]`行，每行中的 4 个元素也是依次存放，整个数组共占用 4×(3×4) = 48 个字节。 　 同理，二维数组 t 类型是`int [2][5]`，t 可分解为 2 个长度为 5 的一维数组`t[0]`、`t[1]`，即两个一维数组的类型类型是`int [5]`，t 占内存 40 个字节。在概念上二维数组有行和列，但在内存中所有的数组元素都是连续排列的，它们之间没有“缝隙”。 　 C 语言提供单目运算符 sizeof，返回一个变量或者类型所占内存的字节数，变量或者类型所占据的内存单元的字节数与机器字长和编译器有关系。现有一段程序如下：

```c
#include <stdio.h> 
int main ()
{  
    int a, b[5],c[10],d[3][4],e[2][5]; 
    printf("a = %d\n",sizeof(a) ); 
    printf("b = %d\n",sizeof(b) );  
    printf("b[0] = %d\n",sizeof(b[0]) );  
    printf("c = %d\n",sizeof(c) ); 
    printf("d = %d\n",sizeof(d) );  
    printf("d[0] = %d\n",sizeof(d[0]) ); 
    printf("d[0][0] = %d\n",sizeof(d[0][0]) );  
    printf("e = %d\n",sizeof(e) );  
    printf("e[0] = %d\n",sizeof(e[0]) );  
    printf("e[0][0] = %d\n",sizeof(e[0][0]) ); 
    return 0;
}
```

运行这段程序，应该可以获取到类似如下结果（不同编译器运行的结果可能不一致）： `a = 4` `b = 20` `b[0] = 4` `c = 40` `d = 48` `d[0] = 16` `d[0][0] = 4` `e = 40` `e[0] = 20` `e[0][0] = 4`



> 正如同没有纯粹的数组一样，也没有纯粹的指针，指针数据类型和数组类型一样，是一种派生数据类型，即是一种借助其他数据类型构造出来的数据类型。

#### 基本类型变量的地址（指针）与整数的加减运算

　　 现有变量定义如下：

```c
double d, *pd;
```

在调用`scanf("%ld",&d);`函数输入变量`d`的值时，表达式`&d`就是一个指针类型的数据，那么`&d`的值是多少呢？变量`d`的内存单元是程序运行时编译器安排的，`&d`的值是变量`d`所占据的那块内存单元`8`个字节中第一个字节的编号，`&d `的值是个指针常量，类型是`double *`，改变`&d`的值就相当于改变变量`d`的存储空间的位置，因此这是根本不可能的。如果想查看一下`&d` 的值是多少，可以通过调用`printf("%p",&d);`用十六进制格式输出`&d `的值，一般指针类型数据的输出格式是`%p`。 　 指针变量`pd`的类型是`double *`，我们可以将`&d`的值赋值给`pd`，称`pd`指向`d`，即：

```c
pd = &d;
```

同理，如果有变量定义：

```c
int a, *pa = &a;
```

那么，`&a `的值也是一个指针常量，类型是`int *`。也就是说，`&a `和`&d `都是地址，但类型不同，`double *`和`int *`是不同的指针类型， 这种区别体现在和整数进行的加减运算上。  `pa`和`pd`都是指针变量，但是`pa`的类型是`int *`，`pb`的类型是`double *`，我们也可以说指针变量`pa`的基类型是`int `，指针变量`pd`的基类型是`double `。

请看下面示例：   

```c
#include <stdio.h> 
int main ()
{
    int a, *pa = &a; 
    double d, *pd = &d;  
    printf("&a     =  %p \n", &a );
    printf("&a+1   =  %p \n", &a+1 );
    printf("++pa   =  %p \n", ++pa );  
    printf("&d     =  %p \n",&d );
    printf("&d+1   =  %p \n",&d+1 );  
    printf("++pd   =  %p \n", ++pd );
    return 0;
}
```

运行这段程序，应该可以获取到类似如下结果： 

`&a     =  00CFFDF4` 

`&a+1   =  00CFFDF8`

 `++pa   =  00CFFDF8` 

`&d     =  00CFFDE4` 

`&d+1   =  00CFFDEC` 

`++pd   =  00CFFDEC`

从运算结果可以看出：`int *`类型地址加 1，结果实际是增加`4`，` double *`类型地址加 1，结果实际是增加`8`，正好是对应的`int`和`double`类型所占内存的字节数。

#### 一维数组与指针

对普通变量的地址进行加减运算，没有意义，但是数组中的所有元素在内存中是连续排列的，整个数组占用的是一块内存，将数组的第 `i `个元素的地址加 1 就可得到第 `i+1` 个元素的地址，减加 1 就可得到第 `i-1` 个元素的地址。 　 请看下面示例：   

```c
#include <stdio.h> 
int main ()
{
    int a[4], b[10], *p;  
    printf("&a     =  %p \n", &a ); 
    printf("&a+1   =  %p \n", &a+1 ); 
    printf("&b      =  %p \n", &b ); 
    printf("&b+1    =  %p \n", &b+1 ); 
    printf("a      =  %p \n", a ); 
    printf("a+1    =  %p \n", a+1 ); 
    printf("b      =  %p \n", b ); 
    printf("b+1    =  %p \n", b+1 ); 
    return 0;
}
```

得到的结果是：

```c
&a     =  006FFA9C
&a+1   =  006FFAAC
&b      =  006FFA6C
&b+1    =  006FFA94
a      =  006FFA9C
a+1    =  006FFAA0
b      =  006FFA6C
b+1    =  006FFA70
```

分析运行结果：

- 对于一维数组` a`来说，`a`的类型是`int[4]`，`&a`的类型是`int[4]*`，`a + 1`增加的地址值是`4`， `&a + 1`增加的地址值是`16`。
- 对于一维数组` b`来说，`b`的类型是`int[10]`，`&b`的类型是`int[10]*`，`b + 1`增加的地址值是`4`，`&b + 1`增加的地址值是`40`。
- 不同长度的一维数组的数组名，在使用过程中都会转换为指向数组第`0`个元素的指针。因此，我们可以将`a`赋值给指针变量`p`，也可以将`b`赋值给指针变量`p`。

#### 二维数组与指针

进一步研究二维数组类型的地址与整数的加减运算，请看示例：

```c
#include <stdio.h> 
int main ()
{
    int  d[3][4], e[2][5];   
    printf("&d     =  %p \n", &d );   
    printf("&d+1     =  %p \n", &d+1 );   
    printf("d     =  %p \n", d );  
    printf("d+1   =  %p \n", d+1 );    
    printf("d[0]     =  %p \n", d[0] );  
    printf("d[0]+1   =  %p \n", d[0]+1 );  
    printf("&e     =  %p \n", &e ); 
    printf("&e+1     =  %p \n", &e+1 );  
    printf("e     =  %p \n", e );  
    printf("e+1   =  %p \n", e+1 ); 
    printf("e[0]     =  %p \n", e[0] );  
    printf("e[0]+1   =  %p \n", e[0]+1 );  
    return 0;
}
```

运行这段程序应该可以获取到类似如下结果：

```c
&d     =  0133FB30
&d+1     =  0133FB60
d     =  0133FB30
d+1   =  0133FB40
d[0]     =  0133FB30
d[0]+1   =  0133FB34
&e     =  0133FB00
&e+1     =  0133FB28
e     =  0133FB00
e+1   =  0133FB14
e[0]     =  0133FB00
e[0]+1   =  0133FB04
```

分析运行结果：

- 对于二维数组`d`，`d`的类型为`int[3][4]`，`d + 1`增加的地址值是`16`，对于二维数组`e`，`e`的类型为`int[2][5]`，`e + 1`增加的地址值是`20`。
- 系统把二维数组`d`分解成`3`个`int [4]`类型的一维数组`d[0]`，`d[1]`，`d[2]`；系统把二维数组`e`分解成`2`个`int [5]`类型的一维数组`e[0]`，`e[1]`。

我们必须定义不同的指针变量指向这两个不同的二维数组，定义一个指向`d`的指针变量 `pd`和指向`e`的指针变量 `pe`：

```c
int (*pd)[4] = d;
int (*pe)[5] = e;
```

**注意**：`[ ]`的优先级高于`*`，这里`( )`是必须要加的，如果写作`int *pd[4]`，那么应该理解为`int *(pd[4])`，`pd` 就成了一个指针数组，而不是指向数组的指针。

初学者总是分不出指针数组与数组指针的区别：

1. 指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身决定。它是“存储指针的数组”的简称；
2. 数组指针：首先它是一个指针，它指向一个数组，它是“指向数组的指针”的简称。 `pd`是一个指针，它指向一个数组，数组的类型为`int [4]`，这正是`d`所包含的每个一维数组的类型，`pd+1`就前进 `4×4 = 16` 个字节，`pd-1`就后退`16`个字节，也就是说，`pd+1`会使得指针指向二维数组的下一行，`pd-1`会使得指针指向数组的上一行。指针`pd`的类型与二维数组`d`的相同。`pe`是指向数组类型为`int [5]`的一个指针，`pe+1`就前进 `4×5 = 20` 个字节，`pe-1`就后退`20`个字节。二维数组名相当于指向该数组中的一维数组的数组指针，指针`pe`的类型与二维数组`e`的相同。

还要注意的是，`d[0] + 1`增加的地址值是`4`，`e[0] + 1`增加的地址值也是`4`。



> 指针变量不同于一般变量，存的是变量的地址，在同一系统下地址长度都是相同的，所以不同类型的指针长度都一样。

32位的操作系统的寻址空间是`0~2`的`32`次方，即`0x00000000~0xFFFFFFFF`，指针长度为`4`个字节； 64位的操作系统的寻址空间是`0~2`的`64`次方，即`0x0000000000000000~0xFFFFFFFFFFFFFFFF`，指针长度为`8`个字节 所以，不管是`char*`, `int*`, `float*`，还是自定义类型的指针，所有类型的指针变量在`32`位系统上都是`4`字节， `64`位系统上都是`8`字节。

##### 指针数组

一个数组的元素值为指针变量则称该数组是指针数组，即指针数组是一组有序的指针变量的集合。指针数组的所有元素都必须是具有相同存储类型和指向相同数据类型的指针变量。

指针数组说明的一般形式为：                                   `类型说明符 *数组名[数组长度]` 其中类型说明符为指针值所指向的变量的类型。例如：                                  `int *p[3];` 表示`p`是一个指针数组，它有三个数组元素，每个元素值都是一个指向整型变量的指针变量。

##### 指针的指针

如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。 　 通过指针访问变量称为间接访问。由于指针变量直接指向变量，所以可以称为“单级间址”；而如果通过指向指针的指针变量来访问变量则构成“二级间址”，如图所示：

![img](https://data.educoder.net/api/attachments/1136076)

<video src="https://video.educoder.net/sv/4f0a4916-173a9b5a66b/4f0a4916-173a9b5a66b.mp4" controls="true" controlslist="nodownload" width="90%" height="55%" poster="https://video.educoder.net/44d1c6a7c61642cc90909f88d4fbc894/snapshots/ffbaf2f30ee847c79b49be15b0178f15-00005.jpg" style="box-sizing: border-box;"></video>

　　

指针变量也是一种变量，也会占用存储空间，不同基类型的指针变量各占多少字节数呢？

请看示例程序：

```c
#include <stdio.h> 
int main ()
{ 
    int* a, **b, *c[4], (*d)[5]; 
    printf("a = %d \n", sizeof(a) ); 
    printf("b = %d \n", sizeof(b) ); 
    printf("c = %d \n", sizeof(c)); 
    printf("d = %d \n", sizeof(d) );  
    return 0;
}
```

运行这段程序应该可以获取到类似如下结果：

```c
a = 8` `b = 8` `c = 32` `d = 8
```

从运算结果可以看出：  1）a，b，d 所占字节数都为 8。 2）数组 c 的数组元素都是指针类型，每个数组元素占 8 个字节，因此长度为 4 的指针数组共占 32 个字节。 　

#### 指针数组

一个数组的元素值为指针变量则称该数组是**指针数组**，即指针数组是一组有序的指针变量的集合。指针数组的所有元素都必须是具有相同存储类型和指向相同数据类型的指针变量。指针数组说明的一般形式为：

```c
类型说明符 *数组名[数组长度]
```

其中类型说明符为指针值所指向的变量的类型。例如：

```c
int *p[3];
```

表示`p`是一个指针数组，它有三个数组元素，每个元素值都是一个指向整型变量的指针变量。

除了每个元素的数据类型不同，指针数组和普通数组在其他方面都是一样的，下面是一个简单的例子：

```c
#include <stdio.h>
int main()
{
    int a = 16, b = 92, c = 100;        
    int *p[3] = {&a, &b, &c}; //定义一个指针数组并且初始化   
    printf("%d, %d, %d\n", *p[0], *p[1], *p[2]);    
    return 0;
}
```

执行结果如下： `16, 92, 100`

分析：程序中，`p`是一个指针数组，它包含了`3`个元素`p[0]`，`p[1]`，`p[2]`，每个元素都是一个指针类型。在定义`p`数组的同时，我们使用变量 a、b、c 的地址对它进行了初始化，这和普通数组是多么地类似。`printf()` 语句中，`p[i]`表示获取第`i`个元素的值，该元素是一个指针，还需要在前面增加一个`*` 才能取得它指向的数据，也即`*p[i]`的形式。
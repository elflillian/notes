# 函数

函数的本质是一段可以重复使用的代码，每一个函数用来实现一个特定的功能，这段代码被提前编写好了，放到了指定的文件中，使用时直接调取即可。

从函数定义角度看，函数可分为**库函数**和**用户自定义函数**两种。

#### 标准库函数

前面程序用到的数学函数`sqrt()`、`pow()`等函数是标准库函数，符合`ANSI C `标准的 C 语言编译器，都必须提供这些库函数。使用`ANSI C`的库函数，必须在程序的开头把该函数所在的头文件包含进来。例如，要使用数学函数时，只要在程序开头将头文件`math.h`包含到程序中即可。 常见的库函数如下：

1. 输入／输出函数(头文件为 stdio.h)：用于完成输入／输出功能；
2. 字符串函数(头文件为 string.h)：用于字符串操作和处理；
3. 数学函数(头文件为 math.h)：用于数学函数计算；
4. 内存管理函数(头文件为 stdlib.h)：用于内存管理；
5. 日期和时间函数(头文件为 time.h)：用于日期、时间的转换操作；
6. 接口函数(头文件为 dos.h)：用于与 DOS、BIOS 和硬件的接口。

#### 用户自定义函数

虽然 C 语言的标准库函数为用户提供了丰富的函数，但还是不能满足用户实际编程的需要。因此，大量的函数还需用户自行定义。

在 C 语言中，所有自定义的函数都必须遵循“**先定义，后使用**”的原则，并且所有的函数定义都是相互平行和独立的，不容许出现嵌套定义。函数定义的基本格式为：

![img](https://data.educoder.net/api/attachments/1137124)

**函数名**是函数的唯一标识，用于说明函数的功能，其命名规则与变量的命名规则相同。为便于区分变量名，通常变量名用小写字母开头的单词组合而成，函数名则用大写字母开头的单词组合而成。

**函数体**必须用一对花括号包围，这里的花括号`{ }`是函数体的定界符。在函数体内部定义的变量只能在函数体内部访问，函数头部参数表里的变量称为形式参数，也是内部变量，也只能在函数体内部访问。函数体执行语句部分是函数的主体，具体描述该函数所应实现的功能。

**形参表**是函数的入口。如果说函数名相当于说明运算的规则的话，那么形参表里的形参就相当于运算的操作数，而函数的返回值就是运算的结果。

函数定义中的**函数返回值类型**是指函数返回值的类型。函数返回值不能是数组，也不能是函数，除此之外任何合法的数据类型都可以是函数返回值的类型，如：char、int、long、float、指针或结构等。

若函数没有函数**返回值**，则需要用`void`定义返回值类型。若函数不需要入口参数，则用`void`代替函数头部中形参表中的内容，或者空着。这就意味着该函数不接收来自调用函数的任何数据。

综上所述，函数定义的第一行称为函数首部，它定义了函数返回值的类型、函数的名字以及调用该函数时需要给出的参数个数及参数的类型。

请看示例：定义求两个整数和的 add( ) 函数，并返回这两个整数的和。

```c
int add( int x,int y )
{
	int  z;         
	z = x + y;         
	return (z);
}
```

对于计算两数之和的函数而言，在函数头部`int add(int x,int y)`中函数名`add`之前的`int`表明函数返回值类型为`int`类型；`(int x,int y)`表明形参列表中有两个参数，形参`x`、`y`的类型均为`int`类型，在`add()`函数的定义时不需要考虑形参的输入，认为在已经有两个参数的基础上，将这两个参数相加；然后通过`return(z)`，将`z`的值作为函数的返回值返回，其中`return`后面的变量或者表达式的值代表函数要返回的值，它的类型应该与函数定义头部中声明的函数返回值类型一致。`add()`函数并不是可运行的程序。

请模仿`add()`函数定义`power()`函数求两个整数的幂。

如何**调用**自定义函数。

为叙述方便，下面将调用其它函数的函数简称**主调函数**，被调用的函数简称为**被调函数**。

#### 形式参数

在定义函数时函数名后面括号中的变量名称为**形式参数**（简称“形参”）。形参可以看做是一个占位符，它没有数据，只能等到函数被调用时接收传递进来的数据。

#### 实际参数

在主调函数中调用一个函数时，函数名后面括号中的参数称为**实际参数**(简称“实参”)。函数被调用时给出的实参包含了实实在在的数据，会被函数内部的代码使用。

在调用函数过程中，主调函数会把实参的值复制给被调函数的形参，这个过程我们称为**参数传递**。

#### 形参和实参的区别和联系

- 形参变量只有在函数被调用时才会分配内存，调用结束后，立刻释放内存，所以形参变量只有在函数内部有效，不能在函数外部使用。
- 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的数据，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参，所以应该提前用赋值、输入等办法使实参获得确定值。
- 实参和形参在数量上、类型上、顺序上必须严格一致，否则会发生“类型不匹配”的错误。当然，如果能够进行自动类型转换，或者进行了强制类型转换，那么实参类型也可以不同于形参类型。
- 函数调用中发生的数据传递是单向的，只能把实参的值传递给形参，而不能把形参的值反向地传递给实参；换句话说，一旦完成数据的传递，实参和形参就再也没有瓜葛了，所以，在函数调用过程中，形参的值发生改变并不会影响实参。

请看示例：如何在`main()`函数中调用求两个整数和的`add( )`函数。

```c
#include <stdio.h>
int add(int x,int y)      //add函数的形式参数，只能是变量
{
    int  z;         
    z = x+y;         
    return(z); 
}
int main()
{  
    int a,b,sum;    
    //printf("请输入两个正整数: \n");     
    scanf("%d%d",&a,&b);   
    sum = add(a,b);               //调用add( )函数，实参可以是变量a与b  
    printf("%d\n",sum);   
    sum = add(a+b,60);            //实参可以是常量或表达式  
    printf("两个数的和=%d.\n",sum);   
    sum = add(a, add(a,b) );      //两次调用add( )函数，求a与a+b的和  
    printf("两个数的和=%d.\n",sum);  
    printf("两个数的和=%d.\n", add(a,2*b) ); //add( )函数的调用作为printf()函数的实参  
    return 0; 
}
```

`main`函数中语句`sum = add(a,b);`中的变量`a`、`b`，称为实参，执行该函数调用语句时， `add()`函数将主函数`main`传递过来的`a`、`b`值，保存于系统为形参`x`和`y`分配的临时空间中，进行加法运算后，再通过`return`语句将计算的结果返回给`main`函数的变量`sum`， `add()`函数执行完毕时形参`x`和`y`所占的临时空间被系统收回。

**求最小公倍数算法：**

最小公倍数 = 两整数的乘积 ÷ 最大公约数

根据求最小公倍数的算法，可以看出如果已知最大公约数，就能很容易求出最小公倍数。而通过辗转相除法和相减法，可以求得最大公约数，下面分别进行介绍。

#### 辗转相除法

已知有两整数`a`和`b`，利用辗转相除法求它们的最大公约数，具体步骤如下： ① `a%b`得余数`t`； ② 若`t=0`，则`b`即为两数的最大公约数； ③ 若`t≠0`，则`a=b`，`b=t`，再回去执行①。

举例说明： 已知`a = 21   b = 28`，辗转相除法步骤如下： ① 执行`t = a%b = 21%28 = 21`， 则`t = 21` ，此时`t`不为`0`，进入循环； ② 先执行`a = 28 ，b = 21`，再执行`t = a%b = 28%21 = 7 `，则`t = 7`，此时`t`不为 0； ③ 先执行` a = 21 , b = 7`，再执行`t = a%b = 21%7 = 0 `，则`t = 0` ，循环结束，`b=7`为最大公约数。

下面是用辗转相除法求最大公约数的函数定义：

```c
int gcd(int a, int b)
{    
    int t = a % b;    
    while( t )    
    {        
        a = b;      
        b = t;         
        t = a%b;        
    }    
    return b;
}
```

#### 相减法

已知有两整数`a`和`b`，利用相减法求它们的最大公约数，具体步骤如下： ① 若`a > b`，则`a = a-b`； ② 若`a < b`，则`b = b-a`； ③ 若`a = b`，则`a`（或`b`）即为两数的最大公约数； ④ 若`a ≠ b`，则再回去执行①。

例如求`a=27`和`b=15`的最大公约数过程为： ①`a = 27－15 = 12     b = 15` ②`a = 12              b = 15-12 = 3` ③`a = 12-3 = 9        b=3` ④`a = 9-3 = 6         b=3` ⑤`a = 6-3 = 3         b=3` 因此，`b = 3`即为最大公约数。

#### 子函数形参定义为基本类型变量

在`main()`函数里定义两个`int`型变量 `a`和`b`，从键盘输入两个整数，调用下面定义的`swap()`函数，再输出这两个实参变量`a`和`b`的值。

```c
#include  <stdio.h>
void  swap(int a, int b); 
int main()
{  
    int  a, b;  
    scanf("%d%d" , &a, &b);  
    swap(a, b);   
    printf("%d %d\n", a, b); 
    return 0;
}
void  swap(int x, int y)         
{    
    int  temp;    
    temp = x;                         
    x = y;              
    y = temp;       
}
```

运行结果：

```c
7 11      # 键盘输入7 11      # 屏幕输出
```

发现`main()`函数中`a`和`b`的值没有交换。这是因为函数调用中发生的数据传递是单向的，只能把实参的值传递给形参，而不能把形参的值反向地传递给实参；换句话说，一旦完成数据的传递，实参和形参就再也没有瓜葛了。所以，在函数调用过程中，形参的值发生改变并不会影响实参。

如果希望在`swap()`函数中交换主函数中两个变量的值，只能将函数的形参由基本类型修改为指针类型，**通过指针交换主函数中两个变量的值**。

#### 子函数形参定义为指针变量类型

```c
void swap(int *p1, int *p2)
{   
    int temp;  
    temp = *p1;  
    *p1 = *p2;  
    *p2 = temp; 
}
```

在`swap()`函数体内部，交换的是形参指向的变量，不是两个形参之间进行交换。在主函数里调用`swap()`函数时，应该将变量`a`和`b`的地址分别传给对应的指针类型的形参。